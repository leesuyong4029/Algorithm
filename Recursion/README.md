# 재귀 (Recursion)

하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

우리가 어떤 문제를 재귀로 푼다는 것은 곧 귀납적인 방식으로 문제를 해결하겠다는 뜻

ex)
1번 도미노가 쓰러진다.
k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다.
-> 모든 도미노가 쓰러진다는 결론에 도달 가능
즉 우리가 지금까지 당연하게 생각하던 절차지향적인 사고를 탈피해야 함

```java
void func1(int n) {
    if(n == 0) return;
    cout << n << ' ';
    func1(n-1);
```
func1(1)이 1을 출력한다.

func1(k)가 k k-1 k-2 ... 1을 출력하면 
func1(k+1)은 k+1 k k-1 ... 1을 출력한다.

k+1 출력 -> func1(k) 호출 = k k-1 k-2 ... 1 출력 

func1 함수가 n부터 1까지 차례로 출력하는 함수임을 귀납적인 사고로 이해하기
첫 번째로 func1(1)이 1을 출력한다. 
func1(k)가 k k-1 k-2 ... 1을 출력하면, k부터 1까지 차례대로 출력하면 func1(k+1)은 k+1부터 1까지 차례로 출력

k+1이 출력된 이후 func1(k)가 호출되고 func1(k)는 k부터 1까지 차례로 출력한다 가정을 했으니 func1(k+1)은 k+1부터 1까지 차례대로 출력함

이 두 문장이 참이기 때문에 귀납적으로 func1 함수가 n부터 1까지 차례로 출력하는 함수임을 알 수 있다. 

## 재귀 함수의 조건
특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함 (Base condition)
모든 입력은 base condition으로 수렴해야 함
```java
void func1(int n) {
    if(n == 0) return;
    cout << n << ' ';
    func1(n-1);
```
올바른 재귀 함수는 반드시 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 합니다.
이러한 입력을 base condition 내지는 base case라고 한다.
그리고 모든 입력은 base condtion으로 수렴해야 한다. 이 코드를 보면 n = 0일 때 자기 자신을 호출하지 않고
종료가 되니 이것이 base condtion이고 우리는 이 함수에 자연수만 넣을테니 모든 입력은 결국엔 n=0으로 수렴하게 됩니다.
이 두 조건 중 어느 하나라도 지켜지지 않는다면 재귀 함수는 결과를 내지 못하고 무한히 들어가다가 런타임 에러가 발생함.

## 재귀에 대한 정보 1
- 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함
- 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
- 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄
재귀는 함수 호출이 꽤 비용이 큰 연산 

## 재귀에 대한 정보 2
- 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있다.
이미 계산할걸 또 계산하는 일이 아주 빈번하다
한 함수가 자기 자신을 여러 번 호출하는 경우에는 시간복잡도가 이상하게 될 수 있어서 조심해야 한다.

## 재귀 함수에 대한 정보
- 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적됨
ex) int 400만개 -> 16MB 소요
